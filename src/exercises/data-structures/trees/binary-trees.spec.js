import { makeMinimalHeightTree } from "./make-minimal-height-tree";
import expect from 'expect.js';
import { generateAutoTree } from "../../../shared/functions/generate-auto-tree";
import { listToTree, BinaryTree } from "../../../shared/classes/binary-tree";
import { getSuccessor } from "./get-successor";
import { firstCommonAncestor } from "./first-common-ancestor";
import { Queue } from "../../../shared/classes/queue";
import { BinarySearchTree } from "../../../shared/classes/binary-search-tree";
import { findSumPaths } from "./find-sum-paths";

describe('Exercises (Trees): Make minimum min heap', function() {
  const testCases = [
    [1,2,3,4,5,6,7],
    [1,2],
    [1],
    [-6,-1,0,4,10,11,15,22,33,106,306,555,556,557,658]
  ];
  it(`Check if the height of the tree is the minimum possible: (${testCases.length} tests)`, function() {
    testCases.forEach((test) => {
      const tree = makeMinimalHeightTree(test);
      expect(tree.getHeight()).to.be(Math.floor(Math.log2(test.length)) + 1);
    });
  });
  const testCases2 = [
    [1,2,3,4,5,6,7],
    [1,2],
    [-6,-1,0,4,10,11,15,22,33,106,306,555,556,557,658]
  ];
  it(`Return false if the trees are not a search tree: (${testCases2.length} tests)`, function() {
    testCases2.forEach((test) => {
      const tree = listToTree([null].concat(test));
      expect(tree.isSearchTree()).to.be(false);
    });
  });
});

describe('Exercises (Trees): Check if tree is balanced', function() {
  const testCases = [
    [1,2,3,4,5,6,7],
    [1,2],
    [1],
    [-6,-1,0,4,10,11,15,22,33,106,306,555,556,557,658]
  ];
  it(`Return true if the tree is balanced: (${testCases.length} tests)`, function() {
    testCases.forEach((test) => {
      const tree = makeMinimalHeightTree(test);
      expect(tree.isBalanced()).to.be(true);
    });
  });
  const tree = generateAutoTree(10000);
  it(`Return true if the tree is balanced for automatic created tree`, function() {
    expect(tree.isBalanced()).to.be(true);
  });
  it(`Return true if the generated tree is a search tree`, function() {
    expect(tree.isSearchTree()).to.be(true);
  });
});

describe('Exercises (Trees): Get successor of a given node', function() {
  const testCases = [
    [1,2,3,4,5,6,7],
    [1,2],
    [1],
    [-6,-1,0,4,10,11,15,22,33,106,306,555,556,557,658]
  ];
  it(`Return true if node successor is correctly found: (${testCases.length} tests)`, function() {
    testCases.forEach((test) => {
      const tree = makeMinimalHeightTree(test);
      test.forEach((v, i) => {
        const expected = i + 1 < test.length ? tree.get(test[i + 1]) : null;
        const succesor = getSuccessor(tree.get(v));
        expect(expected).to.be.eql(succesor);
      });
    });
  });
  it(`Check if all the successor are found in a autogenerated tree.`, function() {
    const tree = generateAutoTree(1000);
    let min = tree.getMin();
    let succesor = getSuccessor(min);
    let count = 1;
    while (succesor) {
      count++;
      min = succesor;
      succesor = getSuccessor(succesor);
    }
    expect(count).to.be(tree.size);
  });
});

describe('Exercises (Trees): Get the common ancestror between 2 nodes', function() {
  const testCases = [
    [-6,-1,0,4,10,11,15,22,33,106,306,555,556,557,658],
    [1,2,3,4,5,6,7],
    [1,2],
    [1],
  ];
  it(`Check if all the root is correctly found as the common ancestror between 2 extremes:
   (${testCases.length} tests)`, function() {
    testCases.forEach((test) => {
      const tree = makeMinimalHeightTree(test);
      const node1 = tree.get(test[0]);
      const node2 = tree.get(test[test.length - 1]);
      expect(firstCommonAncestor(node1, node2)).to.be.eql(tree.root);
    })
  });
  it(`Check if all the root is correctly found as the common ancestror between 2 extremes in autogenerated trees`, function() {
    [1, 10, 100, 1000, 10000].forEach((test) => {
      const tree = generateAutoTree(test);
      const node1 = tree.getMin();
      const node2 = tree.getMax();
      expect(firstCommonAncestor(node1, node2)).to.be.eql(tree.root);
    })
  });
  var checkAncestorFound = function(tree) {
    const node1 = tree.getMin();
    const node2 = tree.getMax();
    expect(firstCommonAncestor(node1, node2)).to.be.eql(tree.root);
  }
  it(`Check if it's works in every subtree in an autogenerated tree `, function() {
    const tree = generateAutoTree(100);
    const queue = new Queue();
    queue.add(tree);
    while(queue.size) {
      const newTree = new BinarySearchTree();
      newTree.root = queue.remove();
      checkAncestorFound(newTree);
      if (newTree.root.left) {
        queue.add(newTree.root.left);
      }
      if (newTree.root.right) {
        queue.add(newTree.root.right);
      }
    }
  });
});

describe('Exercises (Trees): Get the number of paths that sums a given number', function() {
  it(`Check if number of paths are find correctly`, function() {
    const tree = new BinarySearchTree();
    [2, -2, 6, -4, 0, 4, 8, -5, -3, -1, 1, 3, 5, 7, 9].forEach(v => tree.add(v));
    console.log('Number of paths: ', findSumPaths(tree, 17));
  });
  it('returns 0 when no paths sum to value', function() {
    const tree = new BinarySearchTree();
    [10, 9, 11, 8, 7, 6].forEach(v => tree.add(v));
    expect(findSumPaths(tree, 50)).to.eql(0);
    expect(findSumPaths(tree, 5)).to.eql(0);
  });

  it('returns correct counts with balanced tree', function() {
    const tree = new BinarySearchTree();
    [8, 4, 12, 2, 6, 10, 14, 1, 3, 5, 7, 9, 11, 13, 15].forEach(v => tree.add(v));
    expect(findSumPaths(tree, 1)).to.equal(1);
    expect(findSumPaths(tree, 5)).to.equal(2);
    expect(findSumPaths(tree, 10)).to.equal(2);
    expect(findSumPaths(tree, 11)).to.equal(2);
  });

  it('returns correct counts with unbalanced tree', function() {
    const tree = new BinarySearchTree();
    [10, 8, 16, 4, 14, 22, 6, 12, 18, 5, 17, 19].forEach(v => tree.add(v));
    expect(findSumPaths(tree, 10)).to.equal(2);
    expect(findSumPaths(tree, 18)).to.equal(3);
  });

  it('returns correct counts with lots of paths that equal value', function() {
    const tree = new BinarySearchTree();
    [50, 10, 80, 40, 70, 150, 20, 30].forEach(v => tree.add(v));
    expect(findSumPaths(tree, 50)).to.equal(3);
    expect(findSumPaths(tree, 150)).to.equal(3);
  });

  it('minimum value plus his father and brother is found in an autogenerated tree', function() {
    const tree = generateAutoTree(1000);
    const min = tree.getMin();
    const nums = [];
    nums.push(min.value + min.parent.value + min.parent.right.value);
    nums.push(min.value + min.parent.value + min.parent.parent.value + min.parent.parent.right.value);
    nums.push(min.value + min.parent.value + min.parent.parent.value + min.parent.parent.right.value + min.parent.parent.right.right.value);
    nums.forEach((num) =>  expect(findSumPaths(tree, num)).to.greaterThan(0));   
  });

});
