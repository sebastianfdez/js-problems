import { makeMinimalHeightTree } from "./make-minimal-height-tree";
import expect from 'expect.js';
import { generateAutoTree } from "../../../shared/functions/generate-auto-tree";
import { listToTree } from "../../../shared/classes/binary-tree";
import { getSuccessor } from "./get-successor";
import { firstCommonAncestor } from "./first-common-ancestor";
import { Queue } from "../../../shared/classes/queue";
import { BinarySearchTree } from "../../../shared/classes/binary-search-tree";

describe('Exercises (Trees): Make minimum min heap', function() {
  const testCases = [
    [1,2,3,4,5,6,7],
    [1,2],
    [1],
    [-6,-1,0,4,10,11,15,22,33,106,306,555,556,557,658]
  ];
  it(`Check if the height of the tree is the minimum possible: (${testCases.length} tests)`, function() {
    testCases.forEach((test) => {
      const tree = makeMinimalHeightTree(test);
      expect(tree.getHeight()).to.be(Math.floor(Math.log2(test.length)) + 1);
    });
  });
  const testCases2 = [
    [1,2,3,4,5,6,7],
    [1,2],
    [-6,-1,0,4,10,11,15,22,33,106,306,555,556,557,658]
  ];
  it(`Return false if the trees are not a search tree: (${testCases2.length} tests)`, function() {
    testCases2.forEach((test) => {
      const tree = listToTree([null].concat(test));
      expect(tree.isSearchTree()).to.be(false);
    });
  });
});

describe('Exercises (Trees): Check if tree is balanced', function() {
  const testCases = [
    [1,2,3,4,5,6,7],
    [1,2],
    [1],
    [-6,-1,0,4,10,11,15,22,33,106,306,555,556,557,658]
  ];
  it(`Return true if the tree is balanced: (${testCases.length} tests)`, function() {
    testCases.forEach((test) => {
      const tree = makeMinimalHeightTree(test);
      expect(tree.isBalanced()).to.be(true);
    });
  });
  const tree = generateAutoTree(10000);
  it(`Return true if the tree is balanced for automatic created tree`, function() {
    expect(tree.isBalanced()).to.be(true);
  });
  it(`Return true if the generated tree is a search tree`, function() {
    expect(tree.isSearchTree()).to.be(true);
  });
});

describe('Exercises (Trees): Get successor of a given node', function() {
  const testCases = [
    [1,2,3,4,5,6,7],
    [1,2],
    [1],
    [-6,-1,0,4,10,11,15,22,33,106,306,555,556,557,658]
  ];
  it(`Return true if node successor is correctly found: (${testCases.length} tests)`, function() {
    testCases.forEach((test) => {
      const tree = makeMinimalHeightTree(test);
      test.forEach((v, i) => {
        const expected = i + 1 < test.length ? tree.get(test[i + 1]) : null;
        const succesor = getSuccessor(tree.get(v));
        expect(expected).to.be.eql(succesor);
      });
    });
  });
  it(`Check if all the successor are found in a autogenerated tree.`, function() {
    const tree = generateAutoTree(1000);
    let min = tree.getMin();
    let succesor = getSuccessor(min);
    let count = 1;
    while (succesor) {
      count++;
      min = succesor;
      succesor = getSuccessor(succesor);
    }
    expect(count).to.be(tree.size);
  });
});

describe('Exercises (Trees): Get the common ancestror between 2 nodes', function() {
  const testCases = [
    [-6,-1,0,4,10,11,15,22,33,106,306,555,556,557,658],
    [1,2,3,4,5,6,7],
    [1,2],
    [1],
  ];
  it(`Check if all the root is correctly found as the common ancestror between 2 extremes:
   (${testCases.length} tests)`, function() {
    testCases.forEach((test) => {
      const tree = makeMinimalHeightTree(test);
      const node1 = tree.get(test[0]);
      const node2 = tree.get(test[test.length - 1]);
      expect(firstCommonAncestor(node1, node2)).to.be.eql(tree.root);
    })
  });
  it(`Check if all the root is correctly found as the common ancestror between 2 extremes in autogenerated trees`, function() {
    [1, 10, 100, 1000, 10000].forEach((test) => {
      const tree = generateAutoTree(test);
      const node1 = tree.getMin();
      const node2 = tree.getMax();
      expect(firstCommonAncestor(node1, node2)).to.be.eql(tree.root);
    })
  });
  var checkAncestorFound = function(tree) {
    const node1 = tree.getMin();
    const node2 = tree.getMax();
    expect(firstCommonAncestor(node1, node2)).to.be.eql(tree.root);
  }
  it(`Check if it's works in every subtree in an autogenerated tree `, function() {
    const tree = generateAutoTree(100);
    const queue = new Queue();
    queue.add(tree);
    while(queue.size) {
      const newTree = new BinarySearchTree();
      newTree.root = queue.remove();
      checkAncestorFound(newTree);
      if (newTree.root.left) {
        queue.add(newTree.root.left);
      }
      if (newTree.root.right) {
        queue.add(newTree.root.right);
      }
    }
  });
});
